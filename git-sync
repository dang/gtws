#!/bin/bash
#
# Script that syncs a branch of a repo tracking a remote repo.
# Checks first to make sure there's no uncommited changes on the local branch,
# and fails.
# Basically, this means:
#   git checkout master
#   git pull
#   git checkout <original branch>
#   git pull master
#

SUBREMOTE=""

# Set usage output
USAGE="[-h |--help] [-f | --force] [-s | --stash] [-r | --remote]"
LONGUSAGE="\t-h, --help\n\t\tPrint this help message
\t-f, --force\n\t\tSync even if the local branch is not up-to-date
\t-s, --stash\n\t\tStash before syncing, and pop after
\t-r, --remote\n\t\tUpdate submodules to the most recent version"

# Standard functions
GTWS_LOC=$(readlink -f $(dirname "$0"))
source ${GTWS_LOC}/gtws.sh

# Script name
ME=$(basename $0)

# Parse arguments
ARGS=`getopt -o hfsr --long help,force,stash,remote -n "${ME}" -- "$@"`

if [ $? != 0 ] ; then
	usage 
fi
eval set -- "$ARGS"

while true ; do
	case "$1" in
		-h|--help) usage; shift ;;
		-f|--force) FORCE="yes"; shift ;;
		-s|--stash) STASH="yes"; shift ;;
		-r|--remote) SUBREMOTE="--remote"; shift ;;
		--) shift ; break ;;
		* ) usage "Invalid argument $1";;
	esac
done

# Remaining arguments are in $1, $2, etc. as normal

# Source the git environment.  Checks to see if we're in a git repo
SUBDIRECTORY_OK=Yes
source "$(git --exec-path)/git-sh-setup"

GIT_DIR="$(git rev-parse --git-dir 2>/dev/null)"
if git-issvn > /dev/null 2>&1; then
	SVN="yes"
fi

SAVEDIR=${PWD}
BRANCH=$(git branch | grep "\*" | sed 's/\* //')
REMOTE=$(git config --get branch.${BRANCH}.remote)
if test "z$(is_bare_repository)" == ztrue; then
	BARE="true"
fi
if [ -n "${BARE}" ]; then
	UPSTREAM=
elif [ -z "${REMOTE}" ]; then
	UPSTREAM="master"
elif [ "${REMOTE}" == "." ]; then
	# Local tracking branch.  Use it instead of master
	m=$(git config --get branch.${BRANCH}.merge)
	UPSTREAM=${m##*/}
elif [ "${REMOTE}" == "origin" ]; then
	# This branch directly tracks upstream; don't do any form of local upstream
	UPSTREAM=
fi

cd_to_toplevel

if [ -n "${STASH}" ]; then
	git stash || die "Couldn't stash"
fi

if [ -z "${BARE}" -a -z "${FORCE}" ]; then
	git status | grep clean > /dev/null || die "Current branch is not clean"
fi

if [ -n "${UPSTREAM}" ]; then
	echo "Updating ${UPSTREAM} first..."
	git checkout ${UPSTREAM} || die "Could not checkout ${UPSTREAM}"
	if [ -n "${SVN}" ]; then
		git svn rebase || die "rebase of ${UPSTREAM} failed"
	else
		git pull --rebase || die "rebase of ${UPSTREAM} failed"
		git submodule update --init --recursive ${SUBREMOTE} || die "submodule update of ${UPSTREAM} failed"
	fi
	git checkout ${BRANCH}
fi

echo "Updating ${BRANCH}"
if [ -n "${BARE}" ]; then
	git fetch --all || die "update of bare repo failed"
elif [ -n "${SVN}" ]; then
	git svn rebase || die "rebase of ${BRANCH} failed"
else
	git pull --rebase || die "rebase of ${BRANCH} failed"
	git submodule update --init --recursive ${SUBREMOTE} || die "submodule update of ${BRANCH} failed"
fi

if [ -n "${STASH}" ]; then
	git stash pop
fi

cd "${SAVEDIR}"
